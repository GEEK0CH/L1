# Golang

## Задания

1. [Дана структура Human (с произвольным набором полей и методов). Реализовать встраивание методов в структуре Action от родительской структуры Human (аналог наследования).](EX_1.go)
2. [Написать программу, которая конкурентно рассчитает значение квадратов чисел взятых из массива (2,4,6,8,10) и выведет их квадраты в stdout.](EX_2.go)
3. [Дана последовательность чисел: 2,4,6,8,10. Найти сумму их квадратов(2^2+3^2+4^2….) с использованием конкурентных вычислений.](EX_3.go)
4. [Реализовать постоянную запись данных в канал (главный поток). Реализовать набор из N воркеров, которые читают произвольные данные из канала и выводят в stdout. Необходима возможность выбора количества воркеров при старте.
Программа должна завершаться по нажатию Ctrl+C. Выбрать и обосновать способ завершения работы всех воркеров.](EX_4.go)
5. [Разработать программу, которая будет последовательно отправлять значения в канал, а с другой стороны канала — читать. По истечению N секунд программа должна завершаться. ](EX_5.go)
6. [Реализовать все возможные способы остановки выполнения горутины.](EX_6.go)
7. [Реализовать конкурентную запись данны в map.](EX_7.go)
8. [Дана переменная int64. Разработать программу которая устанавливает i-й бит в 1 или 0.](EX_8.go)
9. [Разработать конвейер чисел. Даны два канала: в первый пишутся числа (x) из массива, во второй — результат операции x*2, после чего данные из второго канала должны выводиться в stdout.](task09/main.go)
10. [Дана последовательность температурных колебаний: -25.4, -27.0 13.0, 19.0, 15.5, 24.5, -21.0, 32.5. Объединить данные значения в группы с шагом в 10 градусов. Последовательность в подмножноствах не важна.Пример: -20:{-25.0, -27.0, -21.0}, 10:{13.0, 19.0, 15.5}, 20: {24.5}, etc.](EX_10.go)
11. [Реализовать пересечение двух неупорядоченных множеств.](EX_11.go)
12. [Имеется последовательность строк - (cat, cat, dog, cat, tree) создать для нее собственное множество.](EX_12.go)
13. [Поменять местами два числа без создания временной переменной.](EX_13.go)
14. [Разработать программу, которая в рантайме способна определить тип переменной: int, string, bool, channel из переменной типа interface{}.](EX_14.go)
15. [К каким негативным последствиям может привести данный фрагмент кода, и как это исправить? Приведите корректный пример реализации.](EX_15.go)
16. [Реализовать быструю сортировку массива (quicksort) встроенными методами языка.](EX_16.go)
17. [Реализовать бинарный поиск встроенными методами языка.](EX_17.go)
18. [Реализовать структуру-счетчик, которая будет инкрементироваться в конкурентной среде. По завершению программа должна выводить итоговое значение счетчика.](EX_18.go)
19. [Разработать программу, которая переворачивает подаваемую на ход строку (например: «главрыба — абырвалг»). Символы могут быть unicode.](EX_19.go)
20. [Разработать программу, которая переворачивает слова в строке.Пример: «snow dog sun — sun dog snow».](EX_20.go)
21. [Реализовать паттерн «адаптер» на любом примере.](EX_21.go)
22. [Разработать программу, которая перемножает, делит, складывает, вычитает две числовых переменных a,b, значение которых > 2^20.](EX_22.go)
23. [Удалить i-ый элемент из слайса.](EX_23.go)
24. [Разработать программу нахождения расстояния между двумя точками, которые представлены в виде структуры Point с инкапсулированными параметрами x,y и конструктором.](EX_24.go)
25. [Реализовать собственную функцию sleep.](EX_25.go) 
26. [Разработать программу, которая проверяет, что все символы в строке уникальные (true — если уникальные, false etc). Функция проверки должна быть регистронезависимой.](EX_26.go)

## Устные вопросы

1. Какой самый эффективный способ конкатенации строк
>При случае когда нам нужно конкатенация двух строк хватит и +
```go
string name := firstName + " " + lastName;
```
>Но если же мы будем делать это очень много много раз, то есть смысл использовать более strings.Builder{} для какой нибудь функции, тогда разница будет заметна если сравнивать с первым способом.
```go
c := strings.Builder{}
c.WriteString(firstName)
c.WriteString(lastName)
fmt.Println(c.String())
```

2. Что такое интерфейсы, как они применяются в Go?

>Интерфейсы-это инструменты для определения наборов действий и поведения. Они позволяют объектам опираться на абстракции, а не фактические реализации других объектов. При этом для компоновки различных поведений можно группировать несколько интерфейсов.

3. Чем отличаются RWMutex от Mutex?

>RWMutex применяется со структурами, безопасными для параллельного чтения, но небезопасными для записи. RWMutex позволяет не блокировать чтение, если в данный момент не идёт запись.

4. Чем отличаются буферизированные и не буферизированные каналы?

>Буферизованные каналы принимают ограниченное количество значений без соответствующего приемника для этих значений. Не буферизованы будет принимать отправления только если есть соответствующий прием готовый принять отправленное значение.

5. Какой размер у структуры struct{}{}?

>0

6. Есть ли в Go перегрузка методов или операторов?

>В Go перегрузка функций не поддерживается напрямую, иначе говоря, нельзя создать несколько функций с одинаковыми именами, но разными параметрами.Вместо перегрузки функций в Go можно использовать методы с одинаковыми именами в различных типах.

7. В какой последовательности будут выведены элементы map[int]int?

Пример:

```go
m[0]=1
m[1]=124
m[2]=281
```

>В числовой последовательности индекса если применять fmt.Println().

8. В чем разница make и new?

>make создает общие значения slice, map,channel, а new возвращает только указатели на инициализированную память.

9. Сколько существует способов задать переменную типа slice или map?
>slice:
```go
var s []int
s := []string{}
s := make([]int, 0)
s:= new([]int)
```
>map:
```go
var m map[int]int
m := map[int]int{}
m := make(map[int]int)
m := new(map[int]int)
```

10. Что выведет данная программа и почему?

```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```

> 1 1\
> Выводятся значения самого указателя, а не значение по указателю. 

11. Что выведет данная программа и почему?

```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```

>Рандомные числа в новой строке от 0 до 4 и ошибку fatal error: all goroutines are asleep - deadlock!\
>Передат WaitGroup а не указатель на него.

12. Что выведет данная программа и почему?

```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```

> 0\
> Так как внутри оператора if создается локальная переменная n

13. Что выведет данная программа и почему?

```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```

> [100,2,3,4,5]
> Append создает новый слайс, а вставка в 0 индекс происходит в оригинальный слайс, который и выводится в консоль.

14. Что выведет данная программа и почему?

```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```

> [b,b,a][a,a]\
> Вывод [b,b,a] происходит внутри функции анонимной функции, а вывод  [a,a] это slice main который не подвергался изменениям.
